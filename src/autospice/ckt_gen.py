from src.autospice.parameters import parameters
from src.autospice.gauss_var import gauss_dist
import numpy as np
import copy

class netlist_design(parameters):
	"""docstring for netlist_design"""
	def __init__(self):
		parameters.__init__(self)
		if self.memristor_model == "JART_VCM_1b_det":  #only deterministic model - no code for cycle to variation - just simualtion with variation
			self.static_parameters = " T0=T0 eps=esp epsphib=epsphib phiBn0=phiBn0 phin=phin un=un Nplug=Nplug \ \n a=a ny0=ny0 dWa=dWa Rth0=Rth0 Ninit=Ndiscmin rdet=rdet lcell=lcell \ \n ldet=ldet Rtheff_scaling=Rtheff_scaling RseriesTiOx=RseriesTiOx R0=R0 \ \n"
			self.variablity = "Ndiscmax={} Ndiscmin={} rdet={} ldet={}" # in case want to change parameter there are 4 variablity params
		else:   # use variablity model 
			self.static_parameters = " eps=eps epsphib=epsphib phibn0=phibn0 phin=phin \ \n un=un Ninit=Ndiscmin Nplug=Nplug a=a \ \n nyo=nyo dWa=dWa Rth0=Rth0 rdet=rdet  \ \n lcell=lcell ldet=ldet Rtheff_scaling=Rtheff_scaling RTiOx=RTiOx R0=R0 \ \n Rthline=90471.5 alphaline=0.00392 eps_eff=(eps)*(8.85419e-12) \ \n epsphib_eff=(epsphib)*(8.85419e-12)"
			self.variablity = " Ndiscmax={} Ndiscmin={} lnew = {} rnew= {} " 

	def design_voltage_sources(self):
		"""
			It generates two strings, one containing voltage names (in the form of r0, r1, c0, c1, ...) and the other the pulse 
			characteristics (amplitudes, period, width, etc). Those values are taken from arrays generated by the set_input_voltages function.


		"""
		num_volt_source = 0
		voltages_name = ""
		vpulse = "V{} ({} {}) vsource type={} val0={} val1={} period={} width={} rise={} fall={} \n" #adding voltagesource on each row of the crossbar
		voltage_source = ""
		for i in range(self.rows):
			voltages_name += "r{} ".format(i)
			voltage_source += vpulse.format(str(num_volt_source),"r{} ".format(i),0, self.input_type_r[i], self.volt_0_r[i],self.volt_1_r[i], self.time_period_r[i], self.pulse_width_r[i], self.rise_time_r[i],self.fall_time_r[i])
			num_volt_source += 1
		for j in range(self.columns):
			voltages_name += f"c{j} "
			#no voltages applied to colums
			voltage_source += vpulse.format(str(num_volt_source),"c{} ".format(j),0, self.input_type_c[j], self.volt_0_c[j],self.volt_1_c[j], self.time_period_c[j], self.pulse_width_c[j], self.rise_time_c[j],self.fall_time_c[j])
			num_volt_source += 1
		return voltages_name,voltage_source


	def update_param(self, static_param = "", mean_sigma_param = {}, bools_var = {}):
		"""
		It generates the first part of the netlist, which contains the various parameters used by the simulation. It checks whenever the 
		bools_var are set and creates a gaussian dist in that case. If no variability is set, it returns the default static parameters.
		"""
		var_param = "parameters "
		d_to_d_vardict = {}
		gauss = gauss_dist((self.rows,self.columns))

		# check for variation and create gaussin dist of each parameters according to d_to_d dict parameters
		for variation in bools_var:
			if bools_var[variation]:
				d_to_d_vardict[variation] = gauss_dist(mean_sigma_param[variation]).create_distribution((self.rows,self.columns))

		
		if(len(d_to_d_vardict) == 0):
			print("No random variations.\n")
		else:
			var_param += gauss.make_paramset(d_to_d_vardict) 
			print(f"{len(d_to_d_vardict)} parameters are updated due to variation.\n")
	
		var_param += static_param 
		return var_param


	

	def design_ckt (self, variables = "", static_param= {}, ckt_name= "my_ckt"):
		'''
		Three parts:
		1) Global params, sim params, simul options
		2) Circuit instances
		3) Pulses
		'''
		print("Generating netlist...\n")
		device_parameter_including_variablity = {}
		instance = ""
		all_current = ""
		# iterate for each device
		for rows in range(self.rows):
			for cols in range(self.columns):
				iteration = str(cols+(rows*self.columns)) # total number of iteration - required for creating number of devices

				varing_dict_ = self.variablity_param(iteration) #update dict for variation in each device 

				# the static_param dict is modified only on the parameters which have the bool var set, and the others remain the same
				for value in varing_dict_: # update the parameters for each variation
					static_param[value] = varing_dict_[value]
					
				# generate string for each instance with list of parameters from static_param
				device_parameter_including_variablity = self.parameters_list(param=static_param)
				
				# create instance of device
				instance += "I"+iteration +" (r{} c{}) ".format(rows,cols) + self.memristor_model + " " + device_parameter_including_variablity + "\n"

				# save all the current fro debugging
				all_current += "XBAR.I{}:OE XBAR.I{}:AE".format(iteration,iteration) 

		voltages_name, voltage_source  = self.design_voltage_sources()
		end_ckt = "ends " + ckt_name + "\n"
		subckt_instance = "XBAR (" + voltages_name + ") " + ckt_name + "\n"  # subckt instance according to spectre simulation
		output_data = variables + "\n" + "subckt " + ckt_name + " " # create subckt

		# all combined into single string
		print(f"Netlist generated with {self.rows * self.columns} instances.\n")
		return output_data + voltages_name +"\n" + instance + end_ckt + subckt_instance + voltage_source + "\n save " +all_current + "\n" 


	def create_pulse(self, step_time, pulse_vol, time_unit, pulses = []):
		
		insert_p = False
		concatenated = False

		if not pulses:	# empty list
			start_time = 0
			stop_time = 3000
			concatenated = False

		else:
			start_time = (int(pulses[-2][:-1])+1) # get last time
			stop_time = start_time + 2000
			concatenated = True

		for i in range(start_time, stop_time, step_time):

			if insert_p == False and concatenated == False:
				pulses.append(str(i)+time_unit)
				pulses.append('0')
				pulses.append(str(i+(step_time-1))+time_unit)
				pulses.append('0')
				insert_p = True
				
			else:
				pulses.append(str(i)+time_unit)
				pulses.append(pulse_vol)
				pulses.append(str(i+(step_time-1))+time_unit)
				pulses.append(pulse_vol)
				insert_p = False
				concatenated = False


	def convert_to_pulses(self, in_pulses_list = []):

		pulses_list = []
		for pulse in in_pulses_list:
			if pulse.lower() == "read":
				self.create_pulse(1000, "Read_V", self.time_units, pulses_list)

			elif pulse.lower() == "set":
				self.create_pulse(1000, "Set_V", self.time_units, pulses_list)
				
			elif pulse.lower() == "reset":
				self.create_pulse(1000, "Reset_V", self.time_units, pulses_list)

		if not pulses_list:
			print("Empty list!")
			return
		
		pulses_str = ""
		pulses_str += "V0 (r0 0) vsource type=pwl wave=[\\\n"
		for i in range(0, len(pulses_list)-1, 2):
			pulses_str += pulses_list[i] + '\t' + pulses_list[i+1] + '\t\\\n'

		pulses_str += ']'
		return pulses_str


	def calculate_xbar_size(self, in_pulses_list = []):
		rows = 0
		columns = 0

		for s in in_pulses_list:
			a = s[s.find('(')+1:s.find(')')]
			values = a.split(",")
			row,column = int(values[0]), int(values[1])

			if(row > rows): rows = row
			if(column > columns): columns = column
		
		self.rows = rows
		self.columns = columns



	def gen_netlist_single(self,static_param= {}, pulses = [], file_name = "", memristor_model_path = "", transistor_model_path = ""):
		'''
		Three parts:
		1) Global params, sim params, simul options
		2) Circuit instances
		3) Pulses
		'''
		print("Generating netlist...\n")
		
		ckt_name = "SINGLE"

		str_param = ""
		str_ckt = ""
		str_pulses = ""
		str_instances = ""

		str_param += "global 0\n"
		str_param += "ahdl_include " + "\"" + memristor_model_path + "\"" + "\n"
		str_param += "ahdl_include " + "\"" + transistor_model_path + "\"" + "\n" 
		str_param += "simulatorOptions options vabstol=1e-6 iabstol=1e-12 temp=27 tnom=27 gmin=1e-12\n"
		str_param += f"trans {self.simulation_type} stop={self.simulation_stop_time} errpreset=conservative maxstep ={self.simulation_maxstep}\n"
		str_param += f"saveOptions options save=all currents=all\n"
		str_param += f"save {ckt_name}.I0:OE {ckt_name}.I0:AE\n"
		str_param += f"parameters Read_V = {self.read_v} Set_V = {self.set_v} Reset_V = {self.reset_v}\n"
		str_param += "parameters " + self.parameters_list(param=static_param) + "\n\n\n"

		str_ckt += "subckt 1T1M_ckt MemInput Output TransGate inh_bulk_n\n"
		str_ckt += f"\tM0 (net03 MemInput) {self.memristor_model}"
		str_ckt += "\t" + self.parameters_list(param=static_param, numerical_mode = False) + "\n"
		str_ckt += f"\tT0 (net03 TransGate Output inh_bulk_n) {self.transistor_model}\n"
		str_ckt += "ends 1T1M_ckt\n\n\n"

		k = 0
		for i in range(0, self.rows):
			for j in range(0, self.columns):
				str_instances += f"I{k} (c{j} 0 r{i} 0) 1T1M_ckt\n"
				k += 1

		#str_pulses += self.convert_to_pulses(pulses)
		str_pulses += "\nV1 (c0  0) vsource dc=0\n\n\n"

		to_be_written = str_param + str_ckt + str_instances + str_pulses
		file_ = open(file_name,"w")
		file_.write(to_be_written)
		print(f"Netlist, model path and simulation parameters written to \"{file_name}\"\n")
		print(self.rows, self.columns)



	def write_into_file(self,file_name = "auto_generated.scs", model_path = "JART_VCM_1b_verilog-var.va", to_be_written = " "):

		"""
		Write the netlist generated by the design_ckt function to a scs file, which will be used by the spectre simulator.
		After the netlist is written, it adds the vhdl-A model of the memristor and the simulation parameters (type analysis, stop time, max step)
		"""
		file_ = open(file_name,"w")
		file_.write(to_be_written)

		#ahdl include file
		path_ = "ahdl_include " + "\"" + model_path + "\"" + "\n"  #include the path of model in text file
		file_.write(path_)

		# type of anaylsis - only trans analysis
		ana_sis = "simulatorOptions options vabstol=1e-6 iabstol=1e-12 temp=27 tnom=27 gmin=1e-12" 
		ana_sis = ana_sis + f"\ntrans {self.simulation_type} stop={self.simulation_stop_time} errpreset=conservative maxstep ={self.simulation_maxstep} write=\"spectre.ic\" \
		writefinal=\"spectre.fc\" annotate=status maxiters=5"
		ana_sis = ana_sis + "\nsaveOptions options save=all currents=all saveahdlvars=all"  # type of analysis + saving the input and output current 
		file_.write(ana_sis)   #NEW CHANGE

		print(f"Netlist, model path and simulation parameters written to \"{file_name}\"\n")
